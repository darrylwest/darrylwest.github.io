<!DOCTYPE html>
<!--
Portable Secret generated with https://mprimi.github.io/portable-secret/

This file is self-contained, it embeds an encrypted payload.
It uses your browser's cryptograpy APIs to decrypt it, if you know the password.
-->
<html>
<head>
  <meta charset="UTF-8" />
  <style>
  body {
    background-color: floralwhite;
    font-size: large;
    margin: 50px;
  }

  div {
    margin: 5px;
  }

  pre {
    padding: 5px;
    white-space: pre-wrap;
    word-break: keep-all;
  }

  button {
    font-size: large;
    padding: 12px 20px;
  }

  input {
    font-family: monospace;
  }

  textarea {
    font-family: monospace;
  }

  .decrypted {
    background-color: palegreen;
    border: 2px dotted forestgreen;
  }

  .hint {
    background-color: lavender;
    border: 2px dashed black;
  }

  /*
  pre.decrypted {
  }
  */

  img.decrypted {
    padding: 12px 20px;
  }

  a.decrypted {
    font-size: xx-large;
  }

  input.password_input {
    font-size: large;
    padding: 12px 20px;
  }
  </style>
  <script>
  // Display the encryption inputs on the page (invoked during body onload)
  async function loadValues() {
    document.getElementById("secret_type").innerHTML = secretType
    document.getElementById("salt").setAttribute("value", saltHex)
    document.getElementById("iv").setAttribute("value", ivHex)
    document.getElementById("cipher").innerHTML = cipherHex

    if (secretType == 'file') {
      document.getElementById("target_file").innerHTML = `Download file.${secretExt}`
    }
  }

  // Invoked when the 'Decrypt' button is pressed
  async function decrypt() {
    try {
      setMessage("Generating key from password...")

      // Load salt, convert hex string to byte array
      let salt = hexStringToBytes(saltHex)
      if (salt.length != saltSize) {
        throw new Error(`Unexpected salt size: ${salt.length}`)
      }

      // Load IV, convert hex string to byte array
      let iv = hexStringToBytes(ivHex)
      if (iv.length != blockSize) {
        throw new Error(`Unexpected IV size: ${iv.length}`)
      }

      // Load password, as byte array
      let password = new TextEncoder().encode(document.getElementById("password").value)
      if (password.length == 0) {
        throw new Error(`Empty password`)
      }

      // Wrap password into a Key object, as required by cryptography APIs
      let passwordKey = await window.crypto.subtle.importKey(
        "raw", // Array of bytes
        password,
        {name: "PBKDF2"}, // What algorithm uses the key
        false, // Cannot be extracted
        ["deriveKey"] // What the key is used for
      )

      // Derive a key from the password, using PBKDF2
      let key = await window.crypto.subtle.deriveKey(
        {
          name: "PBKDF2", // https://en.wikipedia.org/wiki/PBKDF2
          salt: salt,
          iterations: iterations,
          hash: "SHA-1", // As per standard v2.0
        },
        passwordKey, // Wrapped password
        {
          name: "AES-GCM", // What algorithm uses the key
          length: keySize * 8, // Key bitsize
        },
        false, // Cannot be extracted
        ["decrypt"] // What the derived key is used for
      )

      setMessage("Decrypting...")

      // Load ciphertext, convert hex string to byte array
      let cipher = hexStringToBytes(cipherHex)

      // Decrypt with AES-GCM
      // https://en.wikipedia.org/wiki/Galois/Counter_Mode
      let decryptedBuffer = await window.crypto.subtle.decrypt(
        {
          name: "AES-GCM", // Name of block cipher algorithm
          iv: iv, // Initialization vector
        },
        key, // Derived key
        cipher // Ciphertext
      )

      // Remove padding (added as necessary for block cipher)
      // https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7
      decrypted = removePadding(new Uint8Array(decryptedBuffer))

      // Render decrypted payload on the page
      if (secretType == "message") {
        // Decode bytes to UTF-8
        plainText = new TextDecoder().decode(decrypted)
        // Display the plaintext on the page
        document.getElementById("target_text").innerHTML = plainText
        document.getElementById("text_output_div").hidden = false
      } else if (secretType == "image") {
        // Transform image to base64 string
        b64Data = btoa(decrypted.reduce((data, byte) => data + String.fromCharCode(byte), ''))
        // Create 'data' URI
        // https://en.wikipedia.org/wiki/Data_URI_scheme
        const imageData = `data:image/${secretExt};base64,${b64Data}`
        // Display image inline
        document.getElementById("target_image").setAttribute("src", imageData)
        document.getElementById("image_output_div").hidden = false
      } else if (secretType == "file") {
        // Transform image to base64 string
        b64Data = btoa(decrypted.reduce((data, byte) => data + String.fromCharCode(byte), ''))
        // Create 'data' URI
        // https://en.wikipedia.org/wiki/Data_URI_scheme
        const fileData = `data:application/octet-stream;base64,${b64Data}`
        // Activate download link
        document.getElementById("target_file").setAttribute("href", fileData)
        document.getElementById("target_file").setAttribute("download", `file.${secretExt}`)
        document.getElementById("file_output_div").hidden = false
      } else {
        throw new Error(`Unknown secret type: ${secretType}`)
      }

      setMessage("Decrypted successfully")

    } catch (err) {
      // TODO better handle failing promises
      setMessage(`Decryption failed: ${err}`)
      return
    }
  }

  // Transform hexadecimal string to Uint8Array
  function hexStringToBytes(input) {
    for (var bytes = [], c = 0; c < input.length; c += 2) {
      bytes.push(parseInt(input.substr(c, 2), 16));
    }
    return Uint8Array.from(bytes);
  }

  // The cleartext input must be padded to a multiple of the block size
  // for encryption. This function removes the padding, expected to be
  // compatible with PKCS#7 described in RFC 5652.
  // https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7
  function removePadding(input) {
    // Last byte is the amount of padding
    padAmount = input[input.length-1]
    unpaddedSize = input.length - padAmount
    return input.slice(0, unpaddedSize)
  }

  // Update page with status of decryption
  function setMessage(msg) {
    document.getElementById("errormsg").innerHTML = msg
  }
  </script>
</head>
<body onload="loadValues()">

  <h1>This page contains a secret <span id="secret_type"></span></h1>
  <h2>Enter the password to decrypt it</h2>
  <h3>Created with <a href="https://mprimi.github.io/portable-secret/">Portable Secret</a></h3>

  <p>
    This file contains a secret (message, file, or image) that can be recovered if you know the password.<br>
    The secret can be decrypted without an internet connection, this file has no dependencies and no data leaves the browser window.
  </p>

  <div>
    <h4>Password hint:</h4>
    <pre class="hint"></pre>
  </div>

  <div>
    <h4>Password:</h4>
    <input type="text" id="password" placeholder="See hint above" class="password_input" required>
  </div>

  <div>
    <button type="button" onclick='decrypt()'>Decrypt</button>
    <span id="errormsg"></span>
  </div>

  <div id="text_output_div" hidden>
    <pre id="target_text" class="decrypted"></pre>
  </div>

  <div id="image_output_div" hidden>
    <img id="target_image" class="decrypted">
  </div>

  <div id="file_output_div" hidden>
    <a id="target_file" class="decrypted">Download</a>
  </div>

  <details>
    <summary>Details</summary>

    These are decryption inputs, that can be safely transmitted in the clear.
    Without the correct password, they are useless.

    <div>
      Salt:
      <input type="text" id="salt" value="" readonly>
    </div>

    <div>
      IV:
      <input type="text" id="iv" value="" readonly>
    </div>

    <div>
      Ciphertext:<br>
      <textarea rows="8" cols="80" id="cipher" readonly></textarea>
    </div>
  </details>
</body>
<script>
const secretType = "message"
const secretExt  = ""
const saltSize   = 16  // bytes
const blockSize  = 16 // bytes
const keySize    = 32   // bytes
const iterations = 1000000
const saltHex    = "b07d9cc89256861fcee4320c30096ae4"
const ivHex      = "432ee87556426ac1a8aba47f47c11084"
const cipherHex  = "9b3c137cd1741e1c5205e4f8708ac0af810e2b703046a87b3232ba9d1f58f32e80fd2e854f93f9b0604fa6ff53033b3b0c2da635da649f7db22ba06f5aafc20cb35ff6210235dc84e2ed7b6f1e54b5ad3f2bf1759547ba508043945818a0f9f524e6d65e1c8dd5deebb00ec7dce1ac34c66e31b3d65009b45e36a539b6a0c7f0115d31236e90085d63dcaa32f07349f4b9534dd203e203e90975854b389bd885852f6fe5382383be6322d271bc850cf9ce9ecffc3723221d9e7839444deafab91474566eb8e24c49c8ef1e1cec828d84010073d60a394748b4d3ff8e99956dfbe7a85a8f4fbd91daa08ed5b69b801a8c68db59410b5365189d901ea99bcdb230abc3eadab367c73aaaaeab21f69905ea434a9284b252e5125c1bcc94be7a9bda9c49cfb52b9aca060f8116aa3d212534cf71a7c94c2928cf9320d8201e522db1a1e7604cfe877fcc56271632d6f20c2084acfe8461d0d271d0cc64aa25fb946478b38f71bd83a6627c41e468934c03f0015c566af8d49f1ce96816ed50a82efe9e73590f5377db8bd58543628f183d6d05a550c9c521ef558840d158853a43f7e7ab04183d8b10944e9a2d8710de247db03a51faa6f1db4e15c5f61cd14798e18bb07146c854479b050b0fbe12e51ee61563e311d3e6f6a7d61c7f581891edfe29e9f4caa23c02d011a24b59130d1fb179eec77b697252181ba8d926d8ede2185850a1d87437851c2f4790feb83be2fd"
</script>
</html>
